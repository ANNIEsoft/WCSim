#include "WCSimDetectorConstruction.hh"

#include "G4Transform3D.hh"
#include "G4Box.hh"
#include "G4Sphere.hh"
#include "G4SubtractionSolid.hh"
#include "G4LogicalVolume.hh"
#include "G4VisAttributes.hh"
#include "G4Material.hh"
#include "G4Polycone.hh"
#include "G4PVPlacement.hh"
#include "G4LogicalBorderSurface.hh"

#include "G4SDManager.hh"
#include "WCSimWCSD.hh"
#include "WCSimLAPPDObject.hh"

#include "G4SystemOfUnits.hh"

//LAPPD logical volume construction.

WCSimDetectorConstruction::LAPPDMap_t WCSimDetectorConstruction::LAPPDLogicalVolumes;

G4LogicalVolume* WCSimDetectorConstruction::ConstructLAPPD(G4String LAPPDName, G4String CollectionName2)
{
  LAPPDKey_t key(LAPPDName,CollectionName2);

  LAPPDMap_t::iterator it = LAPPDLogicalVolumes.find(key);
  if (it != LAPPDLogicalVolumes.end()) {
      //G4cout << "Restore LAPPD" << G4endl;
      return it->second;
  }

  //G4cout << "Create LAPPD" << G4endl;


if (Vis_Choice == "RayTracer"){
    // Blue wireframe visual style
    // Used in the RayTracer visualizer
  G4VisAttributes* WCLAPPDVisAtt = new G4VisAttributes(G4Colour(0.0,0.0,1.0));
  WCLAPPDVisAtt->SetForceSolid(true); // force the object to be visualized with a surface
  WCLAPPDVisAtt->SetForceAuxEdgeVisible(true); // force auxiliary edges to be shown 
}

else
   { // Gray wireframe visual style
    // used in OGLSX visualizer
  G4VisAttributes* WCLAPPDVisAtt = new G4VisAttributes(G4Colour(0.2,0.2,0.2));
  WCLAPPDVisAtt->SetForceWireframe(true);}

  G4double expose;
  G4double radius;
  G4double glassThickness;
  
  WCSimLAPPDObject *LAPPD = GetLAPPDPointer(CollectionName2);
  expose = LAPPD->GetExposeHeight();
  radius = LAPPD->GetRadius();
  //glassThickness = LAPPD->GetLAPPDGlassThickness();

  G4double sphereRadius = radius; //radius is actually half length in x,y
  //(expose*expose+ radius*radius)/(2*expose);
  G4double LAPPDOffset =  sphereRadius;

  //All components of the LAPPD are now contained in a single logical volume logicWCLAPPD.
  //Origin is on the blacksheet, faces positive z-direction.
  
  /*G4double LAPPDHolderZ[2] = {0, expose};
  G4double LAPPDHolderR[2] = {radius, radius};
  G4double LAPPDHolderr[2] = {0,0};*/

  /* G4Polycone* solidWCLAPPD = 
   new G4Polycone("WCLAPPD",                    
                  0.0*deg,
                  360.0*deg,
                  2,
                  LAPPDHolderZ,
                  LAPPDHolderr, // R Inner
                  LAPPDHolderR);// R Outer
  */
  G4Box* solidWCLAPPD = 
   new G4Box("WCLAPPD",                    
	     sphereRadius+2.*cm, //half length in x = 8cm
	     sphereRadius+2.*cm, //half length in y = 8cm
	     (sphereRadius/4.)+2.*cm //half length in z
	     ); //

  G4LogicalVolume* logicWCLAPPD =
    new G4LogicalVolume(    solidWCLAPPD,
                            G4Material::GetMaterial("Water"),
                            "WCLAPPD",
                            0,0,0);

if (Vis_Choice == "RayTracer"){
// Makes the volume containing the LAPPD visible, solid, and forces the auxiliary edges to be viewed.
  G4VisAttributes* WCLAPPDVisAtt = new G4VisAttributes(G4Colour(0.0,0.0,1.0));
  WCLAPPDVisAtt->SetForceSolid(true); // force the object to be visualized with a surface
  WCLAPPDVisAtt->SetForceAuxEdgeVisible(true); // force auxiliary edges to be shown 

    logicWCLAPPD->SetVisAttributes(WCLAPPDVisAtt);}

else{
// Makes the volume containg the LAPPD invisible for normal visualization
    logicWCLAPPD->SetVisAttributes(G4VisAttributes::Invisible);
 }

//Need a volume to cut away excess behind blacksheet
 G4Box* solidCutOffTubs =
   new G4Box(    "cutOffLAPPDs",
		 0.1*m,
		 0.1*m,
		 0.1*m);


  //Create LAPPD Interior
  /* G4Sphere* tmpSolidInteriorWCLAPPD =
      new G4Sphere(    "tmpInteriorWCLAPPD",
                       0.0*m,(sphereRadius-glassThickness),
                       0.0*deg,360.0*deg,
                       0.0*deg,90.0*deg);
  */
  G4Box* tmpSolidInteriorWCLAPPD = 
   new G4Box("tmpInteriorWCLAPPD",                    
	     (sphereRadius*m-glassThickness),  //half length in x = 8cm
	     (sphereRadius*m-glassThickness),  //half length in y = 8cm
	     (sphereRadius/4.*m-glassThickness)//half length in z
	     );//

  G4Transform3D transform = G4Transform3D(G4RotationMatrix(), G4ThreeVector(-1*m, -1*m, -1*m));
  G4SubtractionSolid* solidInteriorWCLAPPD =
      new G4SubtractionSolid(    "InteriorWCLAPPD",
				 tmpSolidInteriorWCLAPPD,
				 solidCutOffTubs,
                                 transform);

  // "Air" here is not true air, but a modified material
  // with n = 1 and a very short absorption length
  G4LogicalVolume* logicInteriorWCLAPPD =
    new G4LogicalVolume(    solidInteriorWCLAPPD,
			    G4Material::GetMaterial("Air"),
			    "InteriorWCLAPPD",
			    0,0,0);

  G4cout<<"From ConstructLAPPD: LAPPDOffset= "<<LAPPDOffset<<" expose= "<<expose<<G4endl;
  G4VPhysicalVolume* physiInteriorWCLAPPD =
      new G4PVPlacement(0,
			G4ThreeVector(0, 0, -1.0*LAPPDOffset),
			logicInteriorWCLAPPD,
			"InteriorWCLAPPD",
			logicWCLAPPD,
			false,
			0);

if (Vis_Choice == "RayTracer"){
// Adding color and forcing the inner portion of the LAPPD's to be viewed
  G4VisAttributes* WCLAPPDVisAtt = new G4VisAttributes(G4Colour(0.0,0.0,1.0));
  WCLAPPDVisAtt->SetForceSolid(true); // force the object to be visualized with a surface
  WCLAPPDVisAtt->SetForceAuxEdgeVisible(true); // force auxiliary edges to be shown 

  logicInteriorWCLAPPD->SetVisAttributes(WCLAPPDVisAtt);}

else {
// Making the inner portion of the detector invisible for OGLSX visualization
  logicInteriorWCLAPPD->SetVisAttributes(G4VisAttributes::Invisible);
 }

//Create LAPPD Glass Face
/*G4Sphere* tmpGlassFaceWCLAPPD =
   new G4Sphere(    "tmpGlassFaceWCLAPPD",
		    (sphereRadius-glassThickness),
		    sphereRadius,
		    0.0*deg,360.0*deg,
		    0.0*deg,90.0*deg);
  */
 G4Box* tmpGlassFaceWCLAPPD = 
   new G4Box("tmpGlassFaceWCLAPPD",                    
	     (sphereRadius-glassThickness), //half length in x
	     (sphereRadius-glassThickness), //half length in y
	     (sphereRadius-glassThickness)//half length in x
	     );//

 G4SubtractionSolid* solidGlassFaceWCLAPPD =
   new G4SubtractionSolid(    CollectionName2,
			      tmpGlassFaceWCLAPPD,
			      solidCutOffTubs,
                              transform); 

 G4LogicalVolume *logicGlassFaceWCLAPPD =
   new G4LogicalVolume(    solidGlassFaceWCLAPPD,
			   G4Material::GetMaterial("Glass"),
			   CollectionName2,
			   0,0,0);

 G4VPhysicalVolume* physiGlassFaceWCLAPPD =
   new G4PVPlacement(0,
		     G4ThreeVector(0, 0, -1.0*LAPPDOffset),
		     logicGlassFaceWCLAPPD,
		     CollectionName2,
		     logicWCLAPPD,
		     false,
		     0,
		     checkOverlaps);

// For either visualization type, logicGlassFaceWCLAPPD will either be visible or invisible depending on which
// line is commented at the end of the respective if statements

  if (Vis_Choice == "OGLSX")
   { // Gray wireframe visual style
    // used in OGLSX visualizer
  G4VisAttributes* WCLAPPDVisAtt = new G4VisAttributes(G4Colour(0.2,0.2,0.2));
  WCLAPPDVisAtt->SetForceWireframe(true);
  // //logicGlassFaceWCLAPPD->SetVisAttributes(G4VisAttributes::Invisible);
    // logicGlassFaceWCLAPPD->SetVisAttributes(WCLAPPDVisAtt);
   }

  if (Vis_Choice == "RayTracer"){
    // Blue wireframe visual style
    // Used in the RayTracer visualizer
  G4VisAttributes* WCLAPPDVisAtt = new G4VisAttributes(G4Colour(0.0,0.0,1.0));
  WCLAPPDVisAtt->SetForceSolid(true); // force the object to be visualized with a surface
  WCLAPPDVisAtt->SetForceAuxEdgeVisible(true); // force auxiliary edges to be shown 
  ////logicGlassFaceWCLAPPD->SetVisAttributes(G4VisAttributes::Invisible);

  //logicGlassFaceWCLAPPD->SetVisAttributes(WCLAPPDVisAtt);
  }

  else
   { // Gray wireframe visual style
    // used in OGLSX visualizer
  G4VisAttributes* WCLAPPDVisAtt = new G4VisAttributes(G4Colour(0.2,0.2,0.2));
  WCLAPPDVisAtt->SetForceWireframe(true);
  ////logicGlassFaceWCLAPPD->SetVisAttributes(G4VisAttributes::Invisible);
  //logicGlassFaceWCLAPPD->SetVisAttributes(WCLAPPDVisAtt);
   }

  // Instantiate a new sensitive detector 
  // and register this sensitive detector volume with the SD Manager. 
  G4SDManager* SDman = G4SDManager::GetSDMpointer();
  G4String SDName = "/WCSim/";
  SDName += CollectionName2;
  //G4cout<<"-------- testttttt: "<< SDName << G4endl;
  // If there is no such sensitive detector with that SDName yet,
  // make a new one
  if( ! SDman->FindSensitiveDetector(SDName, false) ) {
    // G4cout<<"-------- test2: "<<CollectionName2<<G4endl;
    aWCLAPPD = new WCSimWCSD(CollectionName2,SDName,this );
    SDman->AddNewDetector( aWCLAPPD );
  }

  logicGlassFaceWCLAPPD->SetSensitiveDetector( aWCLAPPD );
  LAPPDLogicalVolumes[key] = logicWCLAPPD;

  //Add Logical Border Surface
  new G4LogicalBorderSurface("GlassCathodeSurface",
                             physiGlassFaceWCLAPPD,
                             physiInteriorWCLAPPD,
                             OpGlassCathodeSurface);
  
  return logicWCLAPPD;
}
